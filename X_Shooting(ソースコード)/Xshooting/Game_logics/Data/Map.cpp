
#include "../../common.h"
#include "../../Game.h"
#include "GameData.h"


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

														/*マップのデータセット*/
//===========================================================================
//							//マップの初期化
// 
// csvファイルを開き、中にあるデータをMAP構造体に代入してマップを生成する。
//　この関数には被弾した後の再スタート時にも入るのでマップの進行等の処理も少し入っている
// ・プレイヤーが被弾し、画面が切り替わる際にマップの進行度が一定以上なら次のステージから再スタートする
// ・ループをするステージ番号を決める。
// ・csvファイルを開き、データをフロントマップとバックマップに流し込む。
// ・各データの初期化
// ・マップチップの読み込み
//===========================================================================

void MAP_Init(MAP* _m) {

	const wchar_t* filename = L"res/Map/MapChip.png";		//マップチップの画像
	FILE* fp;		//フロントマップのデータを入れる変数
	FILE* bp;		//バックマップのデータを入れる変数

	int ret;

	//マップサイズ  縦:780 / 31 = 25	横:600 /31 = 19

	//_m->stage = 2;	//検証用ステージ番号を入力するとそのステージから始まる

	/*マップの進行度が一定値進んでいる場合ステージ数を進める*/
	if (_m->y >= 90 * SCROLL_SPEED) {
		_m->stage++;			
	}

	//ループするステージを設定
	if (_m->stage >= 3) {
		_m->stage = 0;			//3ステージを超えたら0ステージ目に戻る
	}

	/*マップデータと地上物配置データの取得*/
	for (int r = 0; r < 5; r++) {
		//ステージの4分割 + 一面森の0ステージの 5分割されたマップ情報の 1/5 ずつデータにいれていく
		fp = fopen(Map_csvDate[_m->stage].Front[r], "r");
		bp = fopen(Map_csvDate[_m->stage].Back[r], "r");
		for (int r2 = 0; r2 < 19 * 25; r2++) {
			ret = fscanf(fp, "%d,", &_m->split[r].data[r2]);
			ret = fscanf(bp, "%d,", &_m->backmap[r].data[r2]);

		}
		if (ret == EOF) {
			return;
		}
	}

	//ファイルを閉じる
	fclose(fp);	
	fclose(bp);


	/*データの初期化 & 初期設定*/
	for (int r = 0; r < MAP_SPLIT; r++) {
		_m->split[r].F = false;
		_m->backmap[r].F = false;
		_m->split[r].x = 0;
		_m->split[r].y = -SRN_H;		//エリアの左上座標を画面の縦サイズと同じにすることでエリアの一番下から表示される用になる
	}
	_m->split[0].F = true;
	_m->split[0].y = 0;
	_m->split[0].x = 0;
	_m->split_num = 0;
	_m->y = 0;



	LoadDivBmp(filename, 0, 0, 32, 32, MAP_CHIPLINE_W, MAP_CHIPLINE_H, _m->pic);	//マップロード



}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

														/*マップの更新*/

//===========================================================================
//							マップの更新
// 
// 5つに分割されたマップの内、画面内に映っているマップ番号の座標を移動させる
// 画面内に同時に存在できるのは２つ。
// 裏マップも表マップと同期して移動する
// ・フラグが建っているかチェック。
// ・マップのY軸座標が0なら画面内に全て描画し終えたという事なので次の番号のマップを準備する
// ・マップをスクロールさせる
// ・マップのY座標が画面の広さと同じ数値になったら、マップの全てが描画し、
//				完全に画面から見えなくなった状態なのでフラグをfalseにする
// ・_m->split_num == 0となっている場合は次のステージ情報を読み込む
// ・裏マップの同期。
// ・1ステージ全体のY座標を記憶する
// ・MAP_Hが5回分終わる = 1ステージが終わったという事なのでY座標を初期化する
//===========================================================================
void MAP_Update(MAP* _m, SCENE* _sc) {


	/*マップ更新*/
	for (int r = 0; r < MAP_SPLIT; r++) {
		if (_m->split[r].F == true) {			//分割した５つのマップの中でフラグがONになっていると処理に進む

			if (_m->split[r].y == 0 && _sc->frame_count % SCROLL_SPEED == 0) { 		//Y座標が0 = 分割されたマップの一番上の座標まで表示された ので次の分割マップを準備する
				_m->split_num++;								//現在表示されている分割されたマップ番号を一つ進める
				if (_m->split_num >= MAP_SPLIT) {					//マップ番号が上限を超えたら
					_m->split_num = 0;									//マップ番号を0に戻す(一面森のステージ)
				}
				_m->split[_m->split_num].F = true;			//次のマップのフラグをONにして
				_m->split[_m->split_num].y = -SRN_H - 19;	//そのマップの左下Y座標を画面の一番上に設定する
				_m->backmap[_m->split_num].F = true;		//裏マップも表マップと同様に次のマップフラグをONにして
				_m->backmap[r].F = false;						//今表示されているマップのフラグをOFFにする
			}

			/*マップスクロール*/
			if (_sc->frame_count % SCROLL_SPEED == 0) {		//SCROLL_SPEEDによって速度が変化
				_m->split[r].y++;
			}
			if (_m->split[r].y == SRN_H) {		//Y座標が画面の一番下に到達したら
				_m->split[r].F = false;				//フラグをOFFにする
				if (_m->split_num == 0) {			//分割数が0 = 一つのステージが終了
					MAP_Init(_m);							//次のステージのマップ情報をセットする
				}
			}

		}
	}
	/*表マップと裏マップの同期*/
	_m->backmap[_m->split_num].y = -(_m->split[_m->split_num].y + 32);		//画像の座標はスクロールの関係で負の数なので裏の画面は正の数に変換する

	//1ステージ(分割マップ * 5)のY座標を進める。
	if (_sc->frame_count % CHIP_SIZE == 0 && _sc->frame_count != 0) {		//チップサイズ単位のY座標
		_m->y++;
	}
	/*1ステージの終了*/
	if (_m->y > (MAP_H * 5) * SCROLL_SPEED) {
		_m->y = 0;
	}

}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

															/*マップの描写*/

//====================================================================
//								マップの描画
//
// フラグが立っている番号のマップを描画する
//====================================================================

void MAP_Draw(MAP* _m) {

	int count = 0;

	for (int num = 0; num < MAP_SPLIT; num++) {
		if (_m->split[num].F == true) {
			for (int r = 0; r < (MAP_H); r++) {
				for (int r2 = 0; r2 < MAP_W; r2++) {
					DrawBmp(_m->split[num].x + (r2 * 32), _m->split[num].y + (r * 32), _m->pic[_m->split[num].data[r2 + (r * MAP_W)]]);		//照準の描写(ボムの射程距離分、自機から離す)
					count++;
				}
			}
		}
	}
}

