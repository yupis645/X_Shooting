
#include "Boss.h"

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

														/*ボスのデータ初期化*/


//==================================================================================================================================
//								ボスの初期化
// 
// 敵を全て初期化し、他の変数も初期化する
//==================================================================================================================================
void Boss_Init(BOSS* _b) {
	for (int i = 0; i < 5; i++) {
		memcpy(&_b->enemy[i], &E_Init, sizeof(ENEMY_ST));		//データを初期化
	}
	_b->F = false;
	_b->down = false;
	_b->center_x = 0;
	_b->center_y = 0;;
	_b->pic_x = 0;
	_b->pic_y = 0;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

																/*ボスの生成*/
//==================================================================================================================================
//								ボスの生成
// 
// ボスの初期データを受け取り、そこに必要な情報を代入していく
// ・コアと砲台 * 4のステータスを初期化
// ・中心座標と円盤部分の画像の左上座標の設定。スプライトのセット
// ・ループでコア & 砲台を初期化していく
//		->画像の代入、座標の設定、当たり判定の設定
// ・撃破フラグをfalseに出現フラグをtrueにする
//		作成したデータを返り値として返す
//==================================================================================================================================
void Boss_Create(BOSS* _b)
{
	//敵の本体と砲台のステータス初期化
	for (int r = 0; r < 4; r++) {		//砲台 * 4　と　コア
		memcpy(&_b->enemy[r], &G_enemyData[10], sizeof(ENEMY_ST));
	}
	memcpy(&_b->enemy[4], &G_enemyData[11], sizeof(ENEMY_ST));

	//中心座標と円盤部分の画像の左上座標の設定。スプライトのセット
	_b->center_y = -(32 * 11) / 2;			//中心Y座標を設定
	_b->center_x = SRN_W / 2;				//中心X座標を設定
	_b->pic_x = (int)_b->center_x - ((32 * 11) / 2);	//画像のX座標を設定
	_b->pic_y = (int)_b->center_y - ((32 * 11) / 2);	//画像のY座標
	LoadDivBmp(PngData.Boss, 0, 0, 32, 32, 11, 11, _b->pic);		//ボスの画像を分割して保存(110)

	/*アルゴ(砲台)の初期化*/
	for (int r = 0; r < 5; r++) {		//砲台 * 4　と　コア

		/*画像の代入*/
		LoadDivBmp(PngData.BossSub,
			0, 0, _b->enemy[r].pic_size, _b->enemy[r].pic_size, 4, 2, _b->enemy[r].pic);

		/*座標の設定 & アニメーション等の各種設定*/
		//４つの砲台
		if (r < 4) {
			_b->enemy[r].type = r;
			_b->enemy[r].anim = r;			//左下、右下、左上、右上、コアの順で並んでいる画像を振り分ける
			if (r < 2) {
				_b->enemy[r].center_y = _b->center_y + (14 * 3);	//コアより下の座標
			}
			else {
				_b->enemy[r].center_y = _b->center_y - (14 * 3);	//コアより上の座標
			}
			if (r % 2 == 0) {
				_b->enemy[r].center_x = _b->center_x - (14 * 3);	//コアの右側の座標
			}
			else {
				_b->enemy[r].center_x = _b->center_x + (14 * 3);	//コアの左側の座標
			}
		}
		//コア
		else {
			_b->enemy[r].center_x = _b->center_x;
			_b->enemy[r].center_y = _b->center_y;
		}

		/*中心座標から'当たり判定'と'画像'の左上と右下の座標*/
		Hitbox_Sync(&_b->enemy[r].hitbox, _b->enemy[r].hitbox_size,				//RECT:当たり判定 , int:当たり判定の中心座標から見たサイズ
			&_b->enemy[r].center_x, &_b->enemy[r].center_y,						//float:中心座標(X) , 中心座標(Y)
			&_b->enemy[r].pic_x, &_b->enemy[r].pic_y, _b->enemy[r].pic_size);	//int:画像左上のx座標 , 画像左上のy座標 , int:画像のサイズ
	}

	_b->down = false;	//撃破フラグOFF
	_b->F = true;		//出現フラグON
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

														/*ボスのデータ更新*/

//
//==================================================================================================================================
//								ボスの更新処理
// 
// 本体とコアは座標移動以外にすることはない。砲台のみ射撃をする。それぞれ発射間隔が微妙に違う
// ・登場フラグのチェック。falseなら処理には入らない
// ・登場してから既定の位置につくまで画面の下方向に移動する。
//		またコアが破壊された場合は画面のスクロールに合わせて下方向に移動する
// ・一定時間までコアが壊されなかった場合は画面の上方向へ撤退する
// ・画面からボスが見切れたら出現フラグをfalseにする
// 
// ・ここからコア & 砲台の処理のため5回ループに入る
// ・移動フラグや撤退フラグが立っている場合は砲台やコアの座標も移動させる
// ・当たり判定の同期と内部タイマーを進める
// ・ボムに対する当たり判定をする。コアが破壊された場合は砲台も連鎖で破壊する
//==================================================================================================================================
void Boss_Update(PLAYER* _p, BOSS* _b, ENEMY_SHOT* _s, SCENE* _sc,  EFFECT* _f)
{
	/*登場フラグがOFFならUpdateに入らない*/
	if (!_b->F) {	return;		}

	bool move = false;		//移動フラグ

	bool withdraw = false;	//撤退フラグ

	//出現時 & 撃破時のY軸移動(下方向)
	if (_b->center_y <= SRN_H / 4 || _b->down == true) {		//画面の特定の位置まで進む　&　撃墜判定が出ている間は画面外まで前進				
		_b->center_y++;					//中心座標
		_b->pic_y++;					//本体(画像)
		move = true;					//コアや砲台に移動することを知らせる
	}

	//一定時間までに撃破されずにいた場合、撤退する(上方向)
	if (_b->enemy[4].ac_count >= (SRN_H * 4) * SCROLL_SPEED) {		//　コアの内部タイマー > 1ステージ分の長さ進んだら
		_b->center_y -= 2;					//上方向へと移動する
		_b->pic_y -= 2;						//本体の移動
		withdraw = true;				//コアや砲台に移動することを知らせる
	}

	/*画面外に出た場合*/
	if (_b->pic_y == SRN_H - 5 || _b->pic_y == -SRN_H || _b->center_y == -(32 * 11) / 2) {
		_b->F = false;		//登場フラグをOFFにして
#if TestMode
		if (StageRupe == false) {
			//_sc->scene_state = 2;
		}
#endif
		return;				//処理を終える
	}

	

	/*砲台&コアの更新*/
	for (int r = 0; r < 5; r++) {

		if (move) {
			_b->enemy[r].center_y++;		//砲台&コア
		}
		if (withdraw) {
			_b->enemy[r].center_y -= 2;		//砲台、コアの移動
		}

		/*当たり判定の同期*/
		Hitbox_Sync(&_b->enemy[r].hitbox, _b->enemy[r].hitbox_size,				//RECT:当たり判定 , int:当たり判定の中心座標から見たサイズ
			&_b->enemy[r].center_x, &_b->enemy[r].center_y,						//float:中心座標(X) , 中心座標(Y)
			&_b->enemy[r].pic_x, &_b->enemy[r].pic_y, _b->enemy[r].pic_size);	//int:画像左上のx座標 , 画像左上のy座標 , int:画像のサイズ


		//内部タイマーの進行 : 破壊されている場合
		if (_b->enemy[r].hit == true) {				
			if (_sc->frame_count % 10 == 0 && _b->enemy[r].ac_count < 6) {			//10フレームに一度入る & 60フレームまで加算する	
				_b->enemy[r].ac_count++;
			}
			continue;								//破壊されている場合はr番目の処理を終え、次の番号の処理へ
		}
		//内部タイマーの進行 : 破壊されていない場合
		else {
			_b->enemy[r].ac_count++;										//敵の内部タイマーを進める
		}

		

		//撃破された時(コアが破壊されたとき)に砲台が撃破されていなかった場合は自壊させる
		if (_b->down && !_b->enemy[r].hit) {
			_b->enemy[r].ac_count = 0;			//爆発アニメーション用に初期化
			_b->enemy[r].hit = true;			//撃破判定にする
			continue;							//処理を終え次のループへ
		}

		Boss_Moving(_p, &_b->enemy[r], _s, _sc->frame_count);		//敵の行動(numberによって異なる挙動をする)

		/*ボムに対する被弾判定*/
		if (_p->bom.bomber == true) {											//ボムの爆発判定が出ている間はヒット判定をする
			_b->enemy[r].hit = Hit_box(_p->bom.hitbox, _b->enemy[r].hitbox);		//自機のショットに対する被弾判定
			if (_b->enemy[r].hit == true) {
				_b->enemy[r].ac_count = 0;					//爆発アニメーション用に初期化
				state.score += _b->enemy[r].points;			//エネミーの持つ点数をスコアに加算する
				if (r == 4) {	_b->down = true;	}		//コアを破壊した場合は撃破フラグをONにする
			}
		}



	}
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

														/*ボス敵の描写*/


//==================================================================================================================================
//										ボスの描画
// 
//BOSSは本体の画像の上からコアと4つの砲台の画像が被さっている。砲台やコアを破壊したときには被さっていた画像を消すことで下にある本体画像を映す
//本体、砲台、コアの３つを描写する。撃破されている場合は爆発アニメーションも描写する
//==================================================================================================================================
void Boss_Draw(BOSS* _b, EFFECT* _f)
{
	//ボスの出現フラグが出ていない場合は処理を終える
	if (!_b->F) { return; }

	//本体の描写
	for (int r = 0; r <= 10; r++) {
		for (int r2 = 0; r2 <= 10; r2++) {
			int pic_num = r * 11 + r2;													// 0 〜 110の範囲で計算される
			DrawBmp(_b->pic_x + (r2 * 32), _b->pic_y + (r * 32), _b->pic[pic_num]);		//ボス本体の描写
		}
	}

	//砲台,コアの描写
	for (int r = 0; r < 5; r++) {
		//通常
		if (_b->enemy[r].hit == false && _b->down == false) {
			DrawBmp(_b->enemy[r].pic_x, _b->enemy[r].pic_y, _b->enemy[r].pic[_b->enemy[r].anim]);

		}

		//撃破されたとき
		if (_b->enemy[r].hit == true && _b->enemy[r].ac_count < 6) {
			DrawBmp(_b->enemy[r].pic_x - 5, _b->enemy[r].pic_y - 5, _f->DieEffect[_b->enemy[r].ac_count]);
		}

	}
}

//==================================================================================================================================
//								ボスの行動パターン
// 
// コアと砲台の行動。どちらも単純でコアは何もしないし、砲台は一定間隔で射撃する
//==================================================================================================================================
void Boss_Moving(PLAYER* _p, ENEMY_ST* _e, ENEMY_SHOT* _s, int _frame) {

	//アルゴ(A/Gの砲台)
	if (_e->number == 60) {
		ALG(_p->center_x, _p->center_y, _e, _s);
	}
	//A/Gコア(A/Gのコア)
	if (_e->number == 611) {
		CORE(_e);
	}
}
//==================================================================================================================================
//										アルゴ	[コア近くの赤い部分]
// 
// 見た目よりも当たり判定が小さい砲台。それぞれ発射感覚が違う
//==================================================================================================================================
void ALG(float px, float py, ENEMY_ST* _e, ENEMY_SHOT* _s) {
	//敵の番号を0〜12の範囲に落とす
	int number = _e->number - 50;

	//敵弾の発射が可能かの判定
	bool shot_ok = true;				//trueなら弾の発射ができる

	bool shot = false;
	
	//被弾していたらアニメーションを5(何も表示しない)で固定し、処理を終える
	if (_e->hit) { _e->anim = 5; return; }

	//被弾していなければ以下の処理に進む

	switch (_e->type) {
	case 0:
		shot = (rand() % 100 == 0);
		break;
	case 1:
		shot = (rand() % 120 == 0);
		break;
	case 2:
		shot = (rand() % 115 == 0);
		break;
	case 3:
		shot = (rand() % 140 == 0);
		break;
	}
	if (shot == true) {
		if (shot_ok) {
			 E_Shot_Create(_s, px, py, _e->center_x, _e->center_y, 0);		//自機に向かって弾を発射する
		}
		shot = false;
	}

}
//==================================================================================================================================
//								コア [中心の赤いやつ]
// 
// ただの弱点。破壊すると砲台もすべて連鎖撃破できるが、スコアが入らない
// ・破壊されたらアニメーションを5(何も表示しない)に固定する
//==================================================================================================================================
void CORE(ENEMY_ST* _e) {
	if (_e->hit == true) {		_e->anim = 5;	}
}